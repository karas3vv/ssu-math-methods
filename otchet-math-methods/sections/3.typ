= Список смежности Ia
== Условие
Для каждой вершины графа вывести её степень.

== Код (фрагменты кода)
```cpp
// вывести степени вершин
void Graph::printDegrees() const {
    cout << "\nСтепени вершин:\n";

    for (const auto& v : adjList) {
        int outDeg = v.adj.size(); // исходящая степень
        int inDeg = 0;             // входящая степень

        // считаем входящие рёбра
        for (const auto& u : adjList) {
            for (const auto& e : u.adj) {
                if (e.to == v.adress) {
                    inDeg++;
                }
            }
        }

        if (directed) {
            cout << v.adress << ": входящая = " << inDeg 
                 << ", исходящая = " << outDeg << "\n";
        } else {
            // неориентированный граф: петля добавляет ещё 1
            int degree = outDeg;
            for (const auto& e : v.adj) {
                if (e.to == v.adress) degree++;
            }
            cout << v.adress << ": степень = " << degree << "\n";
        }
    }
}
```

== Краткое описание алгоритма
Данный алгоритм вычисляет и выводит степени вершин графа.
=== Что делает
Для ориентированного графа:
+ Исходящая степень - количество дуг, исходящих из вершины (просто размер списка смежности)
+ Входящая степень - количество дуг, входящих в вершину (перебирает все рёбра всех вершин)

Для неориентированного графа:
+ Общая степень - количество инцидентных рёбер
+ Особый случай: петли учитываются дважды (по стандарту теории графов)

== Примеры входных и выходных данных
=== Входные данные
```
A B 4
A C 7
B D 3
C D 6
C E 2
E E 9
F G 5
H H 8
```

=== Выходные данные
```
Степени вершин:
A: входящая = 0, исходящая = 2
B: входящая = 1, исходящая = 1
C: входящая = 1, исходящая = 2
D: входящая = 2, исходящая = 0
E: входящая = 2, исходящая = 1
F: входящая = 0, исходящая = 1
G: входящая = 1, исходящая = 0
H: входящая = 1, исходящая = 1
```
