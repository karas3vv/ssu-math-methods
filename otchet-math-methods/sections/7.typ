= Каркас III
== Условие
Дан взвешенный неориентированный граф из N вершин и M ребер. Требуется найти в нем каркас минимального веса.

Алгоритм, который необходимо реализовать для решения задачи (Прима или Краскала), выдает преподаватель.

== Код (фрагменты кода)
```cpp
void Graph::kruskalMST() const {
    // алгоритм Краскала работает только для неориентированных графов
    if (directed) {
        cout << "Kruskal: граф ориентированный — алгоритм применим только к неориентированным графам.\n";
        return;
    }

    // вспомогательная запись ребра: индексы вершин + вес
    struct ERec { int u, v, w; };

    int n = (int)adjList.size();
    if (n == 0) {
        cout << "Граф пустой.\n";
        return;
    }

    // 1) собираем все рёбра (для неориентированного — только один раз: i < j)
    vector<ERec> edges;
    for (int i = 0; i < n; ++i) {
        for (const auto& e : adjList[i].adj) {
            int j = findVertex(e.to);
            if (j == -1) continue; // защита на случай неконсистентности
            if (i < j) { // добавляем только один экземпляр ребра для неориентированного графа
                edges.push_back({i, j, e.weight});
            }
        }
    }

    if (edges.empty()) {
        cout << "В графе нет рёбер.\n";
        return;
    }

    // 2) сортируем рёбра по весу
    sort(edges.begin(), edges.end(), [](const ERec& a, const ERec& b) {
        return a.w < b.w;
    });

    // 3) DSU (Union-Find) по индексам 0..n-1
    struct DSU {
        vector<int> p, r;
        DSU(int n=0) { p.resize(n); r.assign(n,0); for (int i=0;i<n;++i) p[i]=i; }
        int find(int a) { return p[a]==a ? a : p[a]=find(p[a]); }
        bool unite(int a, int b) {
            a = find(a); b = find(b);
            if (a==b) return false;
            if (r[a] < r[b]) swap(a,b);
            p[b] = a;
            if (r[a]==r[b]) ++r[a];
            return true;
        }
    } dsu(n);

    // 4) построим MST в новом графе mst
    Graph mst(false); // неориентированный
    for (const auto& pt : adjList) mst.addPoint(pt.adress); // добавим все вершины в MST

    int totalWeight = 0;
    vector<ERec> mstEdges;

    cout << "\nАлгоритм Краскала\n";
    for (const auto& er : edges) {
        if (dsu.find(er.u) != dsu.find(er.v)) {
            dsu.unite(er.u, er.v);
            mst.addEdge(adjList[er.u].adress, adjList[er.v].adress, er.w);
            mstEdges.push_back(er);
            totalWeight += er.w;
            cout << "Добавлено ребро: " << adjList[er.u].adress 
                 << " - " << adjList[er.v].adress 
                 << " (вес = " << er.w << ")\n";
        }
    }

    cout << "Суммарный вес минимального остова: " << totalWeight << "\n";

    // сохраним результат в файл
    try {
        mst.saveToFile("mst_output.txt");
        cout << "MST сохранён в mst_output.txt\n";
    } catch (const exception& ex) {
        cout << "Не удалось сохранить MST в файл: " << ex.what() << "\n";
    }
}
```

== Краткое описание алгоритма
Данный алгоритм реализует алгоритм Краскала для построения минимального остовного дерева (MST).
=== Что делает
Находит минимальное остовное дерево - подграф, который:

    Содержит все вершины исходного графа

    Является деревом (связный и ацикличный)

    Имеет минимальный суммарный вес рёбер

Шаги алгоритма:
1. Проверка условий

    Работает только для неориентированных графов

    Проверяет, что граф не пустой

2. Сбор всех рёбер

    Собирает все рёбра графа, избегая дублирования (только i < j)

    Каждое ребро: (индекс_вершины1, индекс_вершины2, вес)

3. Сортировка рёбер

    Сортирует рёбра по возрастанию веса

4. Система непересекающихся множеств (DSU)

    Использует Union-Find для эффективной проверки циклов

    find() - находит представителя множества

    unite() - объединяет два множества

5. Построение MST

    Проходит по отсортированным рёбрам

    Добавляет ребро в MST, если оно не создаёт цикл

    Выводит процесс добавления рёбер

6. Сохранение результата

    Сохраняет полученное MST в файл mst_output.txt

== Примеры входных и выходных данных
=== Входные данные
```
A B 4
A C 2
B C 5
B D 10
C E 3
E D 4
D F 11
E F 5
F G 7
G H 1
H I 6
I J 2
C J 9
```

=== Выходные данные
```
Алгоритм Краскала
Ребро "G -> H" добавлено.
Добавлено ребро: G - H (вес = 1)
Ребро "A -> C" добавлено.
Добавлено ребро: A - C (вес = 2)
Ребро "I -> J" добавлено.
Добавлено ребро: I - J (вес = 2)
Ребро "C -> E" добавлено.
Добавлено ребро: C - E (вес = 3)
Ребро "A -> B" добавлено.
Добавлено ребро: A - B (вес = 4)
Ребро "D -> E" добавлено.
Добавлено ребро: D - E (вес = 4)
Ребро "E -> F" добавлено.
Добавлено ребро: E - F (вес = 5)
Ребро "H -> I" добавлено.
Добавлено ребро: H - I (вес = 6)
Ребро "F -> G" добавлено.
Добавлено ребро: F - G (вес = 7)
Суммарный вес минимального остова: 34
MST сохранён в mst_output.txt
```