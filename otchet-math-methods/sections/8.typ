= Веса IV а
== Условие
Определить, есть ли в графе вершина, каждая из минимальных стоимостей пути от которой до остальных не превосходит N.

== Код (фрагменты кода)
```
void Graph::verticesAllDistances() const {
    if (adjList.empty()) {
        cout << "Граф пуст.\n";
        return;
    }

    string startName;
    cout << "Введите начальную вершину: ";
    cin >> startName;

    int s = findVertex(startName);
    if (s == -1) {
        cout << "Вершина \"" << startName << "\" не найдена.\n";
        return;
    }

    const int INF = INT_MAX / 4;
    int n = vertexCount();
    vector<int> dist(n, INF);
    vector<int> parent(n, -1); // опционально: чтобы восстановить пути
    dist[s] = 0;

    // min-куча: (dist, vertex_index)
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0, s});

    while (!pq.empty()) {
        auto [d, v] = pq.top(); pq.pop();
        if (d != dist[v]) continue; // устаревшая запись в куче

        // проходим все вершины-соседи v (используем adjList)
        for (const auto& e : adjList[v].adj) {
            int to = findVertex(e.to);
            if (to == -1) continue; // защита от неконсистентности
            int w = e.weight;
            if (dist[v] != INF && dist[v] + w < dist[to]) {
                dist[to] = dist[v] + w;
                parent[to] = v;
                pq.push({dist[to], to});
            }
        }
    }

    // вывод расстояний
    cout << "\nКратчайшие расстояния от вершины " << startName << ":\n";
    for (int i = 0; i < n; ++i) {
        cout << adjList[i].adress << " : ";
        if (dist[i] == INF) cout << "недостижима\n";
        else cout << dist[i] << "\n";
    }

    // если тебе нужно проверить условие "все расстояния <= N",
    // можно спросить N и проверить:
    char ask;
    cout << "\nПроверить, что все расстояния ≤ N? (y/n): ";
    cin >> ask;
    if (ask == 'y' || ask == 'Y') {
        int N;
        cout << "Введите N: ";
        cin >> N;
        bool ok = true;
        for (int i = 0; i < n; ++i) {
            if (i == s) continue;
            if (dist[i] == INF || dist[i] > N) { ok = false; break; }
        }
        if (ok) cout << "Все расстояния от " << startName << " до остальных ≤ " << N << "\n";
        else cout << "Не все расстояния ≤ " << N << "\n";
    }
}
```

== Краткое описание алгоритма
Находит кратчайшие расстояния от заданной стартовой вершины до всех других вершин в графе.
=== Что делает
1. Инициализация

Запрашивает у пользователя начальную вершину

Проверяет её существование

Инициализирует массив расстояний INF (бесконечность)

Устанавливает расстояние до стартовой вершины = 0

2. Приоритетная очередь

Использует min-кучу для эффективного выбора вершины с минимальным расстоянием

Хранит пары (расстояние, индекс_вершины)

3. Основной цикл Дейкстры

Извлекает вершину с минимальным расстоянием

Для каждого соседа: проверяет, можно ли улучшить расстояние

Если да - обновляет расстояние и добавляет в очередь

4. Вывод результатов

Показывает расстояния до всех вершин

Отмечает недостижимые вершины

5. Дополнительная проверка

Спрашивает пользователя, проверить ли условие "все расстояния ≤ N"

Выводит результат проверки
== Примеры входных и выходных данных
=== Входные данные
```
A B 4
A C 2
B C 5
B D 10
C E 3
E D 4
D F 11
E F 5
F G 7
G H 1
H I 6
I J 2
C J 9
```

=== Выходные данные
```
Введите начальную вершину: A

Кратчайшие расстояния от вершины A:
A : 0
B : 4
C : 2
D : 9
E : 5
F : 10
G : 17
H : 18
I : 24
J : 11

Проверить, что все расстояния ≤ N? (y/n): y
Введите N: 10
Не все расстояния ≤ 10
```