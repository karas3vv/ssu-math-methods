= Веса IV b
== Условие
Вывести кратчайшие пути из вершины u во все остальные вершины.

== Код (фрагменты кода)
```
void Graph::bellmanFord(const string& start) {
    int n = vertexCount();
    int startIndex = findVertex(start);

    if (startIndex == -1) {
        cout << "Вершина " << start << " не найдена.\n";
        return;
    }

    const long long INF = LLONG_MAX / 4;
    vector<long long> dist(n, INF);
    dist[startIndex] = 0;

    // Алгоритм Беллмана–Форда
    for (int i = 0; i < n - 1; ++i) {
        bool updated = false;
        for (int u = 0; u < n; ++u) {
            if (dist[u] == INF) continue;
            for (const auto& e : adjList[u].adj) {
                int v = findVertex(e.to);
                if (v == -1) continue;
                long long w = e.weight;
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    updated = true;
                }
            }
        }
        if (!updated) break; // оптимизация
    }

    // Проверка на отрицательные циклы (опционально)
    for (int u = 0; u < n; ++u) {
        if (dist[u] == INF) continue;
        for (const auto& e : adjList[u].adj) {
            int v = findVertex(e.to);
            if (v == -1) continue;
            if (dist[u] + e.weight < dist[v]) {
                cout << "Граф содержит цикл отрицательного веса!\n";
                return;
            }
        }
    }

    // Вывод результатов
    cout << "Кратчайшие расстояния от вершины " << start << ":\n";
    for (int i = 0; i < n; ++i) {
        cout << adjList[i].adress << " : ";
        if (dist[i] == INF)
            cout << "недостижима\n";
        else
            cout << dist[i] << "\n";
    }
}
```
== Краткое описание алгоритма
Этот алгоритм реализует алгоритм Беллмана-Форда для поиска кратчайших путей от одной вершины до всех остальных.
=== Что делает
Основная цель:

Находит кратчайшие расстояния от заданной вершины до всех других вершин в графе, работая с отрицательными весами рёбер.
Шаги алгоритма:
1. Инициализация

Находит стартовую вершину

Инициализирует массив расстояний INF (бесконечность)

Устанавливает расстояние до стартовой вершины = 0

2. Основной цикл релаксации

Выполняет n-1 итераций (максимальная длина пути без циклов)

Для каждого ребра u→v проверяет:
dist[u] + weight < dist[v]

Если да - обновляет расстояние до v

Оптимизация: досрочный выход, если на итерации не было изменений

3. Проверка на отрицательные циклы

Выполняет дополнительную итерацию релаксации

Если можно улучшить расстояние - обнаруживает отрицательный цикл

4. Вывод результатов

Показывает расстояния до всех вершин

Отмечает недостижимые вершины

== Примеры входных и выходных данных
=== Входные данные
```
A B 2
A C 5
B C 1
B D 4
C E 3
D E 2
E F 6
B A -1
```
=== Выходные данные
```
Введите имя начальной вершины: A
Кратчайшие расстояния от вершины A:
A : 0
B : 2
C : 3
D : 6
E : 6
F : 12
```